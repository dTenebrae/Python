# Реализовать программу работы с органическими клетками, состоящими из ячеек.
# Необходимо создать класс Клетка. В его конструкторе инициализировать
# параметр, соответствующий количеству ячеек клетки (целое число). В классе
# должны быть реализованы методы перегрузки арифметических операторов:
# сложение (__add__()), вычитание (__sub__()), умножение (__mul__()),
# деление (__truediv__()). Данные методы должны применяться только к клеткам
# и выполнять увеличение, уменьшение, умножение и целочисленное (с округлением
# до целого) деление клеток, соответственно.
# Сложение. Объединение двух клеток. При этом число ячеек общей клетки должно
# равняться сумме ячеек исходных двух клеток.
# Вычитание. Участвуют две клетки. Операцию необходимо выполнять только если
# разность количества ячеек двух клеток больше нуля, иначе выводить
# соответствующее сообщение.
# Умножение. Создается общая клетка из двух. Число ячеек общей клетки
# определяется как произведение количества ячеек этих двух клеток.
# Деление. Создается общая клетка из двух. Число ячеек общей клетки
# определяется как целочисленное деление количества ячеек этих двух клеток.
#
# В классе необходимо реализовать метод make_order(), принимающий экземпляр
# класса и количество ячеек в ряду. Данный метод позволяет организовать ячейки
# по рядам.
# Метод должен возвращать строку вида *****\n*****\n*****..., где количество
# ячеек между \n равно переданному аргументу. Если ячеек на формирование ряда
# не хватает, то в последний ряд записываются все оставшиеся.
# Например, количество ячеек клетки равняется 12, количество ячеек в ряду — 5.
# Тогда метод make_order() вернет строку: *****\n*****\n**.
# Или, количество ячеек клетки равняется 15, количество ячеек в ряду — 5.
# Тогда метод make_order() вернет строку: *****\n*****\n*****.


class Cell:
    def __init__(self, parts):
        self.parts = int(parts)
        self.__i = 0

    def __iter__(self):
        return self

    def __next__(self):
        self.__i += 1
        if self.__i <= self.parts:
            return self.__i
        else:
            raise StopIteration

    def __add__(self, other):
        self.parts += other.parts
        self.make_order(5)

    def __sub__(self, other):
        sub_result = self.parts - other.parts
        if sub_result > 0:
            self.parts = sub_result
            self.make_order(5)
        else:
            print('Less than zero')

    def __mul__(self, other):
        self.parts *= other.parts
        self.make_order(5)

    def __truediv__(self, other):
        self.parts = round(self.parts / other.parts)
        self.make_order(5)

    def make_order(self, parts_number):
        i = 0
        while i < self.parts // parts_number:
            print('*' * parts_number + '\n', end='')
            i += 1
        print('*' * (self.parts % parts_number))


cell1 = Cell(7)
cell2 = Cell(6)

# Testing
cell1 + cell2
print('=' * 10)
cell1 - cell2
print('=' * 10)
cell1 * cell2
print('=' * 10)
cell1 / cell2
print('-' * 10)
cell2.make_order(3)

[print(item, end=' ') for item in cell2]
